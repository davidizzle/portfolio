<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spheres Connected by Lines from JSON</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }

        /* Styling for text elements */
        #textAbove, #textBelow {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            /* opacity: 0; Start invisible for fade-in */
            /* transition: opacity 0.5s ease-in-out; Smooth fade-in */
        }

        #textAbove { top: 10%; }
        #textBelow { bottom: 10%; }

        /* Hide spans initially */
        .hidden-word {
            opacity: 0;
            transition: opacity 0.5s ease-in-out; /* Smooth fade-in */
        }
    </style>
</head>
<body>
    <div id="textAbove"></div>
    <div id="textBelow"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- for fonts -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <!-- for fading font -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 70, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit Controls to navigate the scene
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Light for the scene
        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Soft white light
        scene.add(ambientLight);
        
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        // Sphere geometry and material for the vertices
        const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x6dd8fc });

        let spheres = [];
        let lines; // To hold the lines connecting the spheres
        let faces; // Global variable to store faces data
        let targetPositions = []; // Array to store target positions for the transition

        // Text Variables and functions
        const fullTextAbove = "This is the text above the model";
        const fullTextBelow = "This is the text below the model";
        const textAboveDiv = document.getElementById('textAbove');
        const textBelowDiv = document.getElementById('textBelow');
        let currentWordIndexAbove = 0;
        let currentWordIndexBelow = 0;
        const wordInterval = 500; // Time interval between words in milliseconds
        let lastWordTime = 0; // Keeps track of when the last word was added
        // Function to update text and fade in
        // function updateText(element, text, currentIndex) {
        //     const words = text.split(' ');
        //     if (currentIndex < words.length) {
        //         // Update the text content to show more words
        //         element.textContent = words.slice(0, currentIndex + 1).join(' ');

        //         // Set opacity to 0 before showing, then trigger fade-in
        //         element.style.opacity = 0;
        //         setTimeout(() => element.style.opacity = 1, 500); // Delay to ensure smooth fade

        //         // Increment the index for the next word
        //         return currentIndex + 1;
        //     }
        //     return currentIndex;
        // }
        // Function to set up text with spans for each word
        function setupText(element, text) {
            const words = text.split(' ');
            element.innerHTML = words
                .map(word => `<span class="hidden-word">${word} </span>`)
                .join('');
        }
        // Function to reveal words by changing opacity
        function revealWord(element, index) {
            const wordSpans = element.querySelectorAll('.hidden-word');
            if (index < wordSpans.length) {
                wordSpans[index].style.opacity = 1; // Trigger the CSS fade-in
                return index + 1; // Return the next index
            }
            return index;
        }
        // Set up the text spans for the above and below texts
        setupText(textAboveDiv, fullTextAbove);
        setupText(textBelowDiv, fullTextBelow);
        // End text variables

        let currentIndex = 0;  // Track the current JSON index
        const jsonFiles = ['obj/nothing.json', 'obj/crankshaft.json', 'obj/bull.json', 'obj/antennabase.json'];  // List of JSON files to toggle between
        
        // This should be deprecated in favor of animations to be honest
        const auxJsonDynamic = {
            'obj/antennabase.json': ['obj/antennatop1.json', 'obj/antennatop2.json', 'obj/antennatop3.json']
        }

        function loadJSON(url) {
            return fetch(url)
                .then(response => response.json())
                .catch(error => console.error('Error loading JSON:', error));
        }

        function updateScene(data) {
            // Clear existing spheres and lines
            spheres.forEach(sphere => scene.remove(sphere));
            if (lines) {
                scene.remove(lines);
            }

            spheres = []; // Reset spheres array
            const vertices = data.vertices;
            faces = data.faces; // Store faces data globally

            // Ensure faces is defined and iterable
            if (!Array.isArray(faces)) {
                console.error("Faces data is not in expected array format:", faces);
                return; // Exit if faces are not iterable
            }

            // Create spheres for each vertex position
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(x, y, z);
                 // Unique seeds for each sphere for jiggle effect
                sphere.seed = Math.random() * 2 * Math.PI;
                sphere.seed2 = Math.random();
                sphere.seed3 = Math.random() * 2 * Math.PI;
                sphere.seed4 = Math.random();
                scene.add(sphere);
                spheres.push(sphere);

                // Initialize target positions with the current positions
                targetPositions.push(sphere.position.clone());
            }

            // Initialize line material and create lines based on faces
            updateLines(0.08); // Create initial lines based on faces
        }

        function updateLines(opac) {

            if (lines) {
                scene.remove(lines);
                lines.geometry.dispose(); // Dispose the geometry to free memory
                lines.material.dispose(); // Dispose the material to free memory
                lines = null; // Set lines to null after removal
            }


            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = [];

            // Loop through each face
            for (const face of faces) {
                for (let j = 0; j < face.length; j++) {
                    const startIndex = face[j]; // Get vertex index for the start of the line
                    const endIndex = face[(j + 1) % face.length]; // Wrap around to connect the last vertex to the first
                    
                    // Ensure startIndex and endIndex are valid
                    if (startIndex < spheres.length && endIndex < spheres.length) {
                        const startPos = spheres[startIndex].position;
                        const endPos = spheres[endIndex].position;

                        // Push vertex positions to the line vertices array
                        lineVertices.push(startPos.x, startPos.y, startPos.z, endPos.x, endPos.y, endPos.z);

                    } 
                }
            }
            // Map the average line length to an opacity value (adjust this mapping as needed)
            // This is to provide that initial brightness boost
            const minOpacity = 0; // Minimum opacity for very short lines
            const maxOpacity = 1; // Maximum opacity for very long lines
            const opacity = Math.min(maxOpacity, Math.max(minOpacity, opac));


            // Set the vertices to the line geometry
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
            
            // Create line material with transparency and opacity
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, // Enable transparency
                // opacity: 0.08 // Set opacity (0 = transparent, 1 = opaque)
                opacity: opacity // Set opacity (0 = transparent, 1 = opaque)
            });
            lineMaterial.depthWrite = false;
            
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);
        }
        
        async function transitionToNewPositions(newVertices) {
            
            // If this is a dynamic model
            const randomIndex = Math.floor(Math.random() * 3);
            if ( jsonFiles[currentIndex] == 'obj/antennabase.json')
            {
                // console.log(auxJsonDynamic[jsonFiles[currentIndex]][randomIndex])
                await loadJSON(auxJsonDynamic[jsonFiles[currentIndex]][randomIndex]) // Replace with the path to your new JSON file
                    .then( data => {
                        const initialVertexCount = newVertices.length;
                        newVertices.push(...data.vertices);
                        const newFaces = data.faces.map(face => 
                            face.map(index => (index + initialVertexCount / 3) % newVertices.length) // Adjust indices
                        );
                        faces.push(...newFaces);
                    });
            }

            const newTargetPositions = [];

            // Update target positions based on new vertex data
            for (let i = 0; i < newVertices.length; i += 3) {
                const x = newVertices[i];
                const y = newVertices[i + 1];
                const z = newVertices[i + 2];
                
                // Set the target position for each sphere
                newTargetPositions[i / 3] = new THREE.Vector3(x, y, z);
            }

            targetPositions = newTargetPositions; // Update the target positions
        }

        // Slower jiggle effect
        let Time = 0; // Time variable for slow jiggle
        const timeSpeed = 0.05; // Speed of jiggle
        const margin = 1 // To draw lines
        let lastCheckedTime = 0; // Track last time the condition was checked
        function jiggleSpheres() {

            let allArrived = true; // Flag to check if all spheres have arrived
            let marginTotal = 0;
            let activeSpheres = 0;

            spheres.forEach((sphere, index) => {
                const jiggleFactor = 0.005;
                const offset_x = Math.sin(Time + sphere.seed) * jiggleFactor;
                const offset_y = Math.sin(Time + sphere.seed * 1.1) * jiggleFactor;
                const offset_z = Math.sin(Time + sphere.seed * 1.5) * jiggleFactor;
                sphere.position.x += offset_x;
                sphere.position.y += offset_y;
                sphere.position.z += offset_z;

                // Interpolate positions towards target
                if (targetPositions[index]) {
                    sphere.position.lerp(targetPositions[index], 0.05); // Adjust the factor (0.05) for speed of transition
                }

                // If the target position is unchanged, spin around the object
                if (!targetPositions[index]) {
                            // let radius = ( Math.cos(Time * spinSpeed + sphere.seed) + 5) * 10 ; // Radius of the circular motion
                            const spinSpeed = 0.01; // Speed of the spin
                            sphere.theta = Time * spinSpeed * sphere.seed2 + sphere.seed;
                            sphere.phi = Time * spinSpeed  * sphere.seed4 + sphere.seed3;
                            sphere.radius = 100 + (Math.cos(Time * spinSpeed * 5 + sphere.seed) * sphere.seed2 * 5);
                            sphere.radius1 = ( Math.cos(Time * spinSpeed * 50 + sphere.seed) * sphere.seed2 + 8) * 10;
                            let y_off = 10;
                            let x0, y0, z0;
                            x0 = Math.cos(sphere.theta) * Math.sin(sphere.phi) * sphere.radius;
                            z0 = Math.sin(sphere.theta) * Math.sin(sphere.phi) * sphere.radius;
                            y0 = Math.cos(sphere.phi) * sphere.radius + y_off; // Preserve the original y position
                            // Maintain original y position
                            // sphere.position.y = sphere.position.y; // Preserve the original y position

                            sphere.position.lerp(new THREE.Vector3(x0, y0, z0), 0.01);
                        }

                // Only draw lines within certain margin of desired sphere position
                if(targetPositions[index]) {
                    const distance = sphere.position.distanceTo(targetPositions[index]);
                    if (distance > margin) {
                        allArrived = false; // If any sphere has not arrived, set the flag to false
                    }
                    marginTotal += distance;
                    activeSpheres++;
                }
            });

            Time += timeSpeed; // Increment time for the next frame
            
            // Update lines after jiggling the spheres
            if (allArrived) {
                updateLines(marginTotal / activeSpheres ); // Use the global faces variable
            }

            // If this is a dynamic model
            // Interpolate to new position every second, likely to be deprecated
            const currentTime = performance.now() / 1000; // Get current time in seconds
            if (jsonFiles[currentIndex] == 'obj/antennabase.json' && (currentTime - lastCheckedTime) >= 2)
            {
                lastCheckedTime = currentTime;
                loadJSON(jsonFiles[currentIndex]) // Replace with the path to your new JSON file
                .then(data => {
                    // scene.remove(lines);
                    // lines.geometry.dispose(); // Dispose the geometry to free memory
                    // lines.material.dispose(); // Dispose the material to free memory
                    // lines = null; // Set lines to null after removal
                    faces = data.faces;
                    transitionToNewPositions(data.vertices);
                });
            }
        }

        // Function to handle loading new JSON data
        function loadNewJSON(up) {
            currentIndex = (currentIndex + up) % jsonFiles.length;
            loadJSON(jsonFiles[currentIndex]) // Replace with the path to your new JSON file
                .then(data => {
                    scene.remove(lines);
                    lines.geometry.dispose(); // Dispose the geometry to free memory
                    lines.material.dispose(); // Dispose the material to free memory
                    lines = null; // Set lines to null after removal
                    faces = data.faces;
                    transitionToNewPositions(data.vertices);
                });
        }

        // Load initial JSON file
        loadJSON('obj/tidus.json') // Replace with your initial JSON file path
            .then(updateScene);

        // Update the scene on click
        // window.addEventListener('click', loadNewJSON);
        window.addEventListener('keydown', function(event)  {
            if (event.key == 'ArrowRight') {
                loadNewJSON(1);
            } else if (event.key == 'ArrowLeft') {
                loadNewJSON(-1);
            }
        });
        window.addEventListener('ArrowDown', loadNewJSON(-1));
        window.addEventListener('touchstart', (event) => {
            event.preventDefault();
            loadNewJSON(1);
        });
        // window.addEventListener('touchend', (event) => {
        //     event.preventDefault();
        //     loadNewJSON();
        // });

        // Update the text sprite content
        function updateTextSprite(sprite, newText, duration = 100) {
            const canvas = sprite.material.map.image;
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillText(newText, 0, 48); // Adjust the vertical position if needed
            sprite.material.map.needsUpdate = true;

            // Fade in the sprite's opacity using GSAP
            gsap.to(sprite.material, { opacity: 1, duration: duration }); // Adjust duration for speed of fade

        }

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            // Make the text always face the camera
            // if (textAbove) textAbove.lookAt(camera.position);
            // if (textBelow) textBelow.lookAt(camera.position);   

            jiggleSpheres(); // Call the jiggle function
            controls.update();
            renderer.render(scene, camera);
            // console.log(spheres);

            // Word part
            // Update the text word by word for the above element
            if (time - lastWordTime > wordInterval) {
                if (currentWordIndexAbove < fullTextAbove.split(' ').length) {
                    currentWordIndexAbove = revealWord(textAboveDiv, currentWordIndexAbove);
                }

                // Update the text word by word for the below element
                if (currentWordIndexBelow < fullTextBelow.split(' ').length) {
                    currentWordIndexBelow = revealWord(textBelowDiv, currentWordIndexBelow);
                }

                lastWordTime = time;
            }
        }

        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
