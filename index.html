<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spheres Connected by Lines from JSON</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(70, 50, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit Controls to navigate the scene
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Light for the scene
        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Soft white light
        scene.add(ambientLight);
        
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        // Sphere geometry and material for the vertices
        const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x6dd8fc });

        let spheres = [];
        let lines; // To hold the lines connecting the spheres
        let faces; // Global variable to store faces data
        let targetPositions = []; // Array to store target positions for the transition

        let currentIndex = 0;  // Track the current JSON index
        const jsonFiles = ['obj/parsed.json', 'obj/bull.json'];  // List of JSON files to toggle between
        function loadJSON(url) {
            return fetch(url)
                .then(response => response.json())
                .catch(error => console.error('Error loading JSON:', error));
        }

        function updateScene(data) {
            // Clear existing spheres and lines
            spheres.forEach(sphere => scene.remove(sphere));
            if (lines) {
                scene.remove(lines);
            }

            spheres = []; // Reset spheres array
            const vertices = data.vertices;
            faces = data.faces; // Store faces data globally

            // console.log("Vertices:", vertices);
            // console.log("Faces:", faces);

            // Ensure faces is defined and iterable
            if (!Array.isArray(faces)) {
                console.error("Faces data is not in expected array format:", faces);
                return; // Exit if faces are not iterable
            }

            // Create spheres for each vertex position
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(x, y, z);
                sphere.seed = Math.random() * 2 * Math.PI; // Unique seed for each sphere for jiggle effect
                sphere.seed2 = Math.random();
                sphere.seed3 = Math.random() * 2 * Math.PI; // Unique seed for each sphere for jiggle effect
                sphere.seed4 = Math.random();
                scene.add(sphere);
                spheres.push(sphere);

                // Initialize target positions with the current positions
                targetPositions.push(sphere.position.clone());
            }

            // Initialize line material and create lines based on faces
            updateLines(); // Create initial lines based on faces
        }

        function updateLines() {

            if (lines) {
                scene.remove(lines);
                lines.geometry.dispose(); // Dispose the geometry to free memory
                lines.material.dispose(); // Dispose the material to free memory
                lines = null; // Set lines to null after removal
            }


            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = [];
            // console.log(faces);
            // Loop through each face
            for (const face of faces) {
                for (let j = 0; j < face.length; j++) {
                    const startIndex = face[j]; // Get vertex index for the start of the line
                    const endIndex = face[(j + 1) % face.length]; // Wrap around to connect the last vertex to the first
                    
                    // Ensure startIndex and endIndex are valid
                    if (startIndex < spheres.length && endIndex < spheres.length) 
                        lineVertices.push(
                            spheres[startIndex].position.x, spheres[startIndex].position.y, spheres[startIndex].position.z,
                            spheres[endIndex].position.x, spheres[endIndex].position.y, spheres[endIndex].position.z
                        );
                }
            }

            // Set the vertices to the line geometry
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
            
            // Create line material with transparency and opacity
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, // Enable transparency
                opacity: 0.08 // Set opacity (0 = transparent, 1 = opaque)
            });
            lineMaterial.depthWrite = false;
            
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);
        }
        
        function transitionToNewPositions(newVertices) {

            const newTargetPositions = [];

            // Update target positions based on new vertex data
            for (let i = 0; i < newVertices.length; i += 3) {
                const x = newVertices[i];
                const y = newVertices[i + 1];
                const z = newVertices[i + 2];
                
                // Set the target position for each sphere
                newTargetPositions[i / 3] = new THREE.Vector3(x, y, z);
            }

            // Handle unchanged indices
            // for (let i = 0; i < spheres.length; i++) {
            //     if (newTargetPositions[i] === undefined) {
            //         newTargetPositions[i] = targetPositions[i]; // Keep current position for unused spheres
            //     }
            // }

            targetPositions = newTargetPositions; // Update the target positions
        }

        // Slower jiggle effect
        let Time = 0; // Time variable for slow jiggle
        const timeSpeed = 0.05; // Speed of jiggle
        const margin = 1 // To draw lines
        function jiggleSpheres() {

            let allArrived = true; // Flag to check if all spheres have arrived
            spheres.forEach((sphere, index) => {
                const jiggleFactor = 0.005;
                const offset_x = Math.sin(Time + sphere.seed) * jiggleFactor;
                const offset_y = Math.sin(Time + sphere.seed * 1.1) * jiggleFactor;
                const offset_z = Math.sin(Time + sphere.seed * 1.5) * jiggleFactor;
                sphere.position.x += offset_x;
                sphere.position.y += offset_y;
                sphere.position.z += offset_z;

                // Interpolate positions towards target
                if (targetPositions[index]) {
                    // console.log("TARGET !");
                    // console.log(targetPositions[index]);
                    sphere.position.lerp(targetPositions[index], 0.05); // Adjust the factor (0.05) for speed of transition
                }

                // If the target position is unchanged, spin around the object
                if (!targetPositions[index]) {
                            // console.log("I am getting in here!");
                            // let radius = ( Math.cos(Time * spinSpeed + sphere.seed) + 5) * 10 ; // Radius of the circular motion
                            const spinSpeed = 0.01; // Speed of the spin
                            sphere.theta = Time * spinSpeed * sphere.seed2 + sphere.seed;
                            sphere.phi = Time * spinSpeed  * sphere.seed4 + sphere.seed3;
                            sphere.radius = 100 + (Math.cos(Time * spinSpeed * 5 + sphere.seed) * sphere.seed2 * 5);
                            sphere.radius1 = ( Math.cos(Time * spinSpeed * 50 + sphere.seed) * sphere.seed2 + 8) * 10;
                            let y_off = 10;
                            let x0, y0, z0;
                            x0 = Math.cos(sphere.theta) * Math.sin(sphere.phi) * sphere.radius;
                            z0 = Math.sin(sphere.theta) * Math.sin(sphere.phi) * sphere.radius;
                            y0 = Math.cos(sphere.phi) * sphere.radius + y_off; // Preserve the original y position
                            // Maintain original y position
                            // sphere.position.y = sphere.position.y; // Preserve the original y position

                            sphere.position.lerp(new THREE.Vector3(x0, y0, z0), 0.01);
                        }
                if(targetPositions[index]) {
                    const distance = sphere.position.distanceTo(targetPositions[index]);
                    if (distance > margin) {
                        allArrived = false; // If any sphere has not arrived, set the flag to false
                    }
                }
            });

            Time += timeSpeed; // Increment time for the next frame
            
            // Update lines after jiggling the spheres
            if (allArrived) {
                updateLines(); // Use the global faces variable
            }
        }

        // Function to handle loading new JSON data
        function loadNewJSON() {
            currentIndex = (currentIndex + 1) % jsonFiles.length;
            loadJSON(jsonFiles[currentIndex]) // Replace with the path to your new JSON file
                .then(data => {
                    scene.remove(lines);
                    lines.geometry.dispose(); // Dispose the geometry to free memory
                    lines.material.dispose(); // Dispose the material to free memory
                    lines = null; // Set lines to null after removal
                    transitionToNewPositions(data.vertices);
                    faces = data.faces;
                });
        }

        // Load initial JSON file
        loadJSON('obj/parsed.json') // Replace with your initial JSON file path
            .then(updateScene);

        // Update the scene on click
        window.addEventListener('click', loadNewJSON);
        window.addEventListener('touchstart', (event) => {
            event.preventDefault();
            loadNewJSON();
        });
        // window.addEventListener('touchend', (event) => {
        //     event.preventDefault();
        //     loadNewJSON();
        // });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            jiggleSpheres(); // Call the jiggle function
            controls.update();
            renderer.render(scene, camera);
            // console.log(spheres);
        }

        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
