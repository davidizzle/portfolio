<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Come catturare un'upupa</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add ambient light to the scene
        const light = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(light);

        // Create a grid of spheres and multiple planes to stack along the Z-axis
        const gridSize = 20;  // Number of items in each dimension for each plane
        const spacing = 0.8;    // Spacing between spheres
        const speed = 0.1;    // Speed of movement in the Z direction
        const maxZ = 6;      // Maximum Z value before resetting position
        const numPlanes = 20; // Number of back-to-back planes to create the volumetric effect
        const planeSpacing = (maxZ * 2 + 20)  / numPlanes;  // Distance between each plane
        const spheres = [];

        // Function to create and return a new sphere mesh
        function createSphere(x, y, z) {
            const geometry = new THREE.SphereGeometry(0.06, 0.5, 0.5); // Sphere size and resolution
            const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 1 });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            return sphere;
        }

        // Create multiple planes of spheres
        for (let p = 0; p < numPlanes; p++) {
            const zOffset = -20 -maxZ + p * planeSpacing;  // Stack planes along Z-axis
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const sphere = createSphere(
                        x * spacing - (gridSize * spacing) / 2,
                        y * spacing - (gridSize * spacing) / 2,
                        zOffset  // Offset each plane along Z-axis
                    );
                    spheres.push(sphere);
                    scene.add(sphere);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            spheres.forEach((sphere, index) => {
                // Move each sphere (each plane) in the Z direction
                sphere.position.z += speed*5;

                // Reset position to the back of the "cube" once it passes the front
                if (sphere.position.z > maxZ) {
                    sphere.position.z = -maxZ - 20;  // Move back behind the last plane
                }

                // Calculate color and opacity based on Z position
                const normalizedZ = (sphere.position.z + maxZ) / (2 * maxZ);  // Normalize Z from 0 to 1
                sphere.material.color.setHSL(0.6, 1, 0.5 + normalizedZ * 0.5); // Blue to white (HSL color)
                sphere.material.opacity = 1 - normalizedZ;  // Fade from visible to invisible
            });

            renderer.render(scene, camera);
        }

        // Position the camera to look at the cube of spheres
        camera.position.x = gridSize * 0.5;
        camera.position.y = gridSize * 0.5;  // Move up on Y-axis
        camera.position.z = gridSize * 0.5;  // Keep distance on Z-axis
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        animate();
    </script>
</body>
</html>
